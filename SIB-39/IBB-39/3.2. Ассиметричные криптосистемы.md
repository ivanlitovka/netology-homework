# Домашнее задание к занятию «3.2. Ассиметричные криптосистемы»


### Задача

В этой задаче мы научимся шифровать данные с помощью публичного ключа и расшифровывать с помощью приватного.

Первое, с чего мы должны начать - это сгенерировать ключ. Для этого нужно выбрать алгоритм, размер ключа и passphrase (кодовую фразу).

#### Шаг 1. Создайте закрытый ключ с длиной 2048:

```shell script
openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:2048 -aes256 -out private.key
```

Где [`genpkey`](https://www.openssl.org/docs/manmaster/man1/openssl-genpkey.html) - подкоманда, отвечающая за генерацию ключей.

Введите кодовую фразу два раза (обратите внимание, символы не будут отображаться в целях безопасности).

Откройте файл `private.key` в любом текстовом редакторе (можете просмотреть в терминале с помощью команды `cat private.key`), удостоверьтесь, что он выглядит примерно так:

```text
-----BEGIN ENCRYPTED PRIVATE KEY-----
...
МНОГО БУКВ
...
-----END ENCRYPTED PRIVATE KEY-----
```

#### Шаг 2. Сгенерируйте открытый ключ на базе закрытого: 

```shell script
openssl pkey -pubout -in private.key -out public.key
```

Где [`pkey`](https://www.openssl.org/docs/man1.0.2/man1/pkey.html) - подкоманда, отвечающая за обработку ключей.

Откройте файл `public.key` (можете просмотреть в терминале с помощью команды `cat public.key`) в любом текстовом редакторе, удостоверьтесь, что он выглядит примерно так:

```text
-----BEGIN PUBLIC KEY-----
...
МНОГО БУКВ
...
-----END PUBLIC KEY-----
```

#### Шаг 3. Создайте файл message.txt со своей фамилией

#### Шаг 4. Зашифруйте сообщение с помощью публичного ключа: 

```shell script
openssl pkeyutl -encrypt -pubin -inkey public.key -in message.txt -out cypher.txt
```

Где [`pkeyutl`](https://www.openssl.org/docs/manmaster/man1/openssl-pkeyutl.html) - подкоманда, отвечающая за низкоуровневые операции с публичными ключами (включая шифрование и расшифрование).

Откройте файл `cypher.txt` в любом текстовом редакторе, удостоверьтесь, что он не читабелен.

#### Шаг 5. Убедитесь, что файл `cyper.txt` расшифровывается:

```shell script
openssl pkeyutl -decrypt -inkey private.key -in cypher.txt -out decrypted.txt
```

### Результат

В качестве результата пришлите:
1. Публичный и приватный ключ (`public.key` и `private.key`)
1. Passphrase (строкой)
1. Зашифрованный файл (`cypher.txt`)


[public.key](./files/public.key)
[private.key](./files/private.key)
[cypher.txt](./files/cypher.txt)


## Задача GnuPG: подпись сообщения



#### Шаг 1. Генерация keypair

```shell script
gpg --full-generate-key
```

В диалоговом окне:
1. Выберите тип ключа: `RSA и RSA`
1. Размер ключа: `2048`
1. Срок действия ключа - `0` (не ограничен)

Далее введите:
1. Имя (ваше реальное имя)
1. Email
1. Комментарий оставьте пустым

Для примера (вам не нужно писать `coursar` и `coursar@localhost` - ДЗ будет отправлено на доработку):

![](pic/gpg-generate-keys.png)

После чего вас попросят ввести passphrase для защиты ключа.

#### Шаг 2. Просмотр ключей

```shell script
gpg --list-keys
# либо в коротком формате:
gpg -k
```

Удостоверьтесь, что то, что вы сгенерировали на предыдущем шаге, есть в списке:

![](pic/gpg-list-keys.png)

#### Шаг 3. Подпись сообщения

Создайте текстовый файл с сегодняшней датой в любом формате и сохраните его в файле `message.txt`.

Подпишите его следующей командой (подпись будет создана в виде отдельного файла):

```shell script
gpg --output message.sig --local-user coursar@localhost --detach-sign message.txt
```

Где `coursar@localhost` - это email, который вы указали на первом шаге.

Проверьте, что подпись соответствует сообщению с помощью команды:

```shell script
gpg --verify message.sig message.txt
```

![](pic/gpg-sign-and-verify.png)

#### Шаг 4. Проверка подписи (ложное сообщение)

Создайте текстовый файл `modified.txt` и измените в нём дату на вчерашнюю.

Удостоверьтесь, что проверка подписи теперь не проходит:

```shell script
gpg --verify message.sig modified.txt
```

![](pic/gpg-verify.png)

#### Шаг 5. Экспорт публичного ключа

Для того, чтобы остальные пользователи могли проверять подпись ваших сообщений, вы должны им предоставить ваш публичный ключ.

Для этого нужно его экспортировать с помощью следующей команды:

```shell script
gpg --output public.gpg --armor --export coursar@localhost
```

Где `coursar@localhost` - это email, который вы указали на первом шаге.

По умолчанию, ключ экспортируется в бинарном формате. Опция `--armor` позволяет экспортировать его в текстовом виде.

### Результат

В качестве результата пришлите:
1. Публичный ключ (с шага 5)
1. Файл сообщения и подпись к нему (с шага 3)

[Файл publiv.gpg](./files/public.gpg)
[Файл сообщения](./files/message.txt)
[Файл подписи](./files/message.sig)

## Задача GnuPG: decrypt*

```

ivanlitovka@MacBook-Pro-Ivan ~ % gpg --decrypt message.enc 
gpg: encrypted with rsa2048 key, ID 423BB7DA845A8006, created 2020-08-18
      "netology <student@netology>"
1984
gpg: Подпись сделана вторник, 18 августа 2020 г. 14:50:07 MSK
gpg:                ключом RSA с идентификатором EFDDD64EC65A89E7D882E12DEC12A0D8D7C8B540
gpg:                 издатель "infosec@netology"
gpg: Действительная подпись пользователя "netology <infosec@netology>" [неизвестно]
gpg: WARNING: The key's User ID is not certified with a trusted signature!
gpg:           Нет указаний на то, что подпись принадлежит владельцу.
Отпечаток первичного ключа: EFDD D64E C65A 89E7 D882  E12D EC12 A0D8 D7C8 B540
```

Судя по всему подпись не валидна  
